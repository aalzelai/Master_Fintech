//
// Created by Andoni on 26/09/2018.
//
#include <iostream>
#include <random>
#include "Matriz.h"

matriz::matriz (int f, int c) :
    filas{f},
    columnas{c}
{
    valores = new double [filas*columnas];
    for(int i = 0; i < (filas*columnas) ; i++){
        valores[i] = 0;
    }

};

matriz::matriz() :
    filas{0},
    columnas{0}
{
}

void matriz::pintar_matriz(){
    using namespace std;
    for(int i = 0; i < (filas*columnas); i++){
     cout << valores[i] << " \t";
    if((i+1)%(filas) == 0) cout << "\n";
    }
}

void matriz::rellenar_matriz() {

    std::random_device rd;  //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    std::uniform_real_distribution<> dis(0.0, 100.0);
    for (int n = 0; n < (filas*columnas); ++n) {
        //Use dis to transform the random unsigned int generated by gen into a double in [1, 2)
       valores[n]=dis(gen);
    }
}

matriz matriz::operator+(matriz &m) {
    int i, j;
    int fil = m.filas;
    int col = m.columnas;
    matriz mRes(fil,col);
    for  (i=0;i<(fil*col);i++)
    {
        mRes.valores[i] = this->valores[i]+m.valores[i];
    }
    return mRes;
}

double& matriz::operator()(double f, double c) {
    int valor = (f-1)*(columnas) + c-1;
    return valores[valor];

}

double matriz::calcular_diagonal() {
    double res = 0;
    for(int i = 0; i < filas*columnas; i++) {
        res =+ valores[i];
    };
    return res;
}

matriz matriz::operator*(matriz &m) {
    matriz mRes(filas, m.columnas);
    int i, j, k;
    double r;
    int bj, bk;
    int bsize;

    if(this->bsize > 0) bsize = this->bsize; else bsize = 1;
    for(bj = 0; bj < columnas; bj+=bsize){
        for(bk=0; bk < columnas; bk +=bsize){
            for(i=0; i<columnas; ++i){
                for(j = bj; j < std::min(bj+bsize, columnas); ++j){
                    r = 0;
                    for(k = bk; k < std::min(bk+bsize, columnas); ++k){
                        r +=this->valores[i*this->columnas + k] * m.valores[k*m.columnas+j];
                    }
                    mRes.valores[i*mRes.columnas+j] += r;
                }

            }
        }
    }
    return mRes;


}